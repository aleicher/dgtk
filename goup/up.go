// A package to create upstart scripts. These scripts are essential to make rebooting boxes safe, but contain an
// inherent complexity that requires some understanding of what is going on.
//
// NOTE: This is work in progress. There are quite some options not supported yet!
package goup

import (
	"fmt"
	"os"
	"strings"
)

type Upstart struct {
	Name        string // Name of the upstart script. Used for the file located in /etc/init.
	Description string // Description of the service provided.

	StartOnEvents []string // Events the service should be started on.
	StopOnEvents  []string // Events the service should be stopped at.

	WorkingDirectory string            // Directory to be used as CWD for the exec statement or script.
	Environment      map[string]string // Environment variables set and available in all script sections.
	Exports          []string          // List of env variables to be exported to all events resulting from this job.

	Exec            string // Command to run to start the service.
	Script          string // Script to be executed to start the service.
	PostStartScript string // Script to be executed post start.
	PostStopScript  string // Script to be executed post stop.
	PreStartScript  string // Script to be executed pre start.
	PreStopScript   string // Script to be executed pre stop.

	Expect               string // TODO Expected behavior of the started command (with regard to daemonization).
	Instance             string // TODO Instance handling.
	Respawn              bool   // TODO ???
	RespawnLimitCount    int    // TODO Number of times the job might be respawned in the given interval.
	RespawnLimitInterval int    // TODO Time frame the job might be respawned the given times.
	OomScore             int    // TODO Configuration of the kernel's "Out of memory" killer facility.

	Limit []string    // TODO Resource limits of the job started
	Nice  int         // TODO Set the job's scheduling priority.
	Gid   string      // TODO All processes are run as the given group.
	Uid   string      // TODO All processes are run as the given user.
	Umask os.FileMode // TODO File mode creation mask used for the job.

	KillSignal      string // TODO Signal used to terminate the service.
	KillTimeout     int    // TODO Number of seconds to wait for the kill signal to succeed.
	ReloadSignal    string // TODO Signal to be used for initiating a service reload.
	NormalExitCodes []int  // TODO List of exit codes considered 'normal'.

	Manual bool // TODO Don't start automatically, ignoring the start/stop configuration.
	Task   bool // TODO A short lived job.
}

// Create a string containing the content of the upstart script (should be save to "/etc/init/{{ u.Name }}").
func (u *Upstart) CreateScript() string {
	content := []string{"# Upstart script generated by github.com/dynport/dgtk/goup"}

	content = u.setDescription(content)
	content = u.setStartEvents(content)
	content = u.setStopEvents(content)

	content = u.setWorkingDirectory(content)
	content = u.setEnvironment(content)
	content = u.setExports(content)

	content = u.setExecAndScript(content)
	content = u.setStartClosure(content)
	content = u.setStopClosure(content)

	return strings.Join(content, "\n") + "\n"
}

func (u *Upstart) setDescription(content []string) []string {
	if u.Description == "" {
		return content
	}
	return append(content, fmt.Sprintf("description \"%s\"", u.Description))
}

func (u *Upstart) setStartEvents(content []string) []string {
	if u.StartOnEvents == nil || len(u.StartOnEvents) == 0 {
		return content
	}
	for idx := range u.StartOnEvents {
		content = append(content, fmt.Sprintf("start on %s", u.StartOnEvents[idx]))
	}
	return content
}

func (u *Upstart) setStopEvents(content []string) []string {
	if u.StopOnEvents == nil || len(u.StopOnEvents) == 0 {
		return content
	}
	for idx := range u.StopOnEvents {
		content = append(content, fmt.Sprintf("stop on %s", u.StopOnEvents[idx]))
	}
	return content
}

func (u *Upstart) setWorkingDirectory(content []string) []string {
	if u.WorkingDirectory != "" {
		return append(content, fmt.Sprintf("chdir %s", u.WorkingDirectory))
	}
	return content
}

func (u *Upstart) setEnvironment(content []string) []string {
	for key, value := range u.Environment {
		content = append(content, fmt.Sprintf("env %s=%v", key, value))
	}
	return content
}

func (u *Upstart) setExports(content []string) []string {
	for i := range u.Exports {
		content = append(content, fmt.Sprintf("export %s", u.Exports[i]))
	}
	return content
}

func (u *Upstart) setExecAndScript(content []string) []string {
	if u.Exec != "" && u.Script != "" {
		panic("both exec and script specified")
	}
	if u.Exec == "" && u.Script == "" {
		panic("neither exec or script must be specified")
	}

	if u.Exec != "" {
		content = append(content, fmt.Sprintf("exec %s", u.Exec))
	} else if u.Script != "" {
		content = addScript(content, "script", "end script", u.Script)
	}

	return content
}

func (u *Upstart) setStartClosure(content []string) []string {
	if u.PreStartScript != "" {
		content = addScript(content, "pre-start script", "end script", u.PreStartScript)
	}

	if u.PostStartScript != "" {
		content = addScript(content, "post-start script", "end script", u.PostStartScript)
	}

	return content
}

func (u *Upstart) setStopClosure(content []string) []string {
	if u.PreStopScript != "" {
		content = addScript(content, "pre-stop script", "end script", u.PreStopScript)
	}

	if u.PostStopScript != "" {
		content = addScript(content, "post-stop script", "end script", u.PostStopScript)
	}

	return content
}

func addScript(content []string, startTag, endTag, body string) []string {
	content = append(content, startTag)
	lines := strings.Split(body, "\n")
	for idx := range lines {
		content = append(content, "\t"+lines[idx])
	}
	return append(content, endTag)
}
